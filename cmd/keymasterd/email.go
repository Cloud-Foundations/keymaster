package main

import (
	"bytes"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/Cloud-Foundations/golib/pkg/communications/configuredemail"
)

const emailAdminTemplateData = `From: {{.AdminAddr}}
To: {{.AdminAddrs}}
Subject: Keymaster Bootstrap OTP generated for {{.Username}}

A Bootstrap OTP was generated by {{.AdminUser}} for user: {{.Username}}

The OTP fingerprint is: {{printf "%x" .Fingerprint}}

The OTP will expire in {{.Duration}}.
`

const emailUserTemplateData = `From: {{.AdminAddr}}
To: {{.UserAddr}}
Subject: Welcome to Keymaster

Hi, {{.Username}}. Welcome to Keymaster. Please log in to:
{{.HostIdentity}}

Your one-time passcode (Bootstrap OTP) is:
{{.OTP}}

In case of debugging, your OTP fingerprint is: {{printf "%x" .Fingerprint}}

Please register your U2F security key after login.

You have {{.Duration}} to complete this operation before this passcode expires.
`

type bootstrapOtpEmailData struct {
	AdminAddrs   string
	AdminAddr    string
	AdminUser    string
	Duration     time.Duration
	Fingerprint  [4]byte
	HostIdentity string
	OTP          string
	UserAddr     string
	Username     string
}

func (state *RuntimeState) initEmailDefaults() {
	state.Config.Email.AwsSecretLifetime = time.Minute * 5
}

func (state *RuntimeState) setupEmail() error {
	if state.Config.Email.Domain == "" {
		return nil
	}
	var err error
	state.emailManager, err = configuredemail.New(
		state.Config.Email.EmailConfig, logger)
	if err != nil {
		return err
	}
	state.emailAdminTemplate, err =
		template.New("Bootstrap OTP Admin Email").Parse(emailAdminTemplateData)
	if err != nil {
		return err
	}
	state.emailUserTemplate, err =
		template.New("Bootstrap OTP User Email").Parse(emailUserTemplateData)
	if err != nil {
		return err
	}
	return nil
}

func (state *RuntimeState) sendBootstrapOtpEmail(hash []byte, OTP string,
	duration time.Duration, adminUser, targetUser string) error {
	emailData := bootstrapOtpEmailData{
		AdminAddr:    adminUser + "@" + state.Config.Email.Domain,
		AdminUser:    adminUser,
		Duration:     duration,
		HostIdentity: state.Config.Base.HostIdentity,
		OTP:          OTP,
		UserAddr:     targetUser + "@" + state.Config.Email.Domain,
		Username:     targetUser,
	}
	copy(emailData.Fingerprint[:], hash[:4])
	adminUsers := make(map[string]struct{})
	adminUsers[adminUser] = struct{}{}
	for _, user := range state.Config.Base.AdminUsers {
		adminUsers[user] = struct{}{}
	}
	if state.gitDB != nil {
		for _, adminGroup := range state.Config.Base.AdminGroups {
			users, err := state.gitDB.GetUsersInGroup(adminGroup)
			if err != nil {
				return err
			}
			for _, user := range users {
				adminUsers[user] = struct{}{}
			}
		}
	}
	adminAddrs := make([]string, 0, len(adminUsers))
	for user := range adminUsers {
		adminAddrs = append(adminAddrs, user+"@"+state.Config.Email.Domain)
	}
	sort.Strings(adminAddrs)
	emailData.AdminAddrs = strings.Join(adminAddrs, ",")
	buffer := &bytes.Buffer{}
	if err := state.emailAdminTemplate.Execute(buffer, emailData); err != nil {
		return err
	}
	err := state.emailManager.SendMail(emailData.AdminAddr, adminAddrs,
		buffer.Bytes())
	if err != nil {
		return err
	}
	buffer = &bytes.Buffer{}
	if err := state.emailUserTemplate.Execute(buffer, emailData); err != nil {
		return err
	}
	err = state.emailManager.SendMail(emailData.AdminAddr,
		[]string{emailData.UserAddr}, buffer.Bytes())
	if err != nil {
		return err
	}
	return nil
}
